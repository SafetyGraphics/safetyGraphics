#' @title   mappingTabUI 
#' @description  UI that facilitates the mapping of all data domain
#' 
#' @param id module id
#' @param meta metadata for all domains
#' @param domainData list of data files for each domain
#' @param mappings optional data frame containing stacked mappings for all domains
#' @param standards optional list of data standards like the ones generated by \code{detectStandard()}
#' 
#' @importFrom stringr str_to_upper
#' 
#' @export

mappingTabUI <- function(id, meta, domainData, mappings=NULL, standards=NULL){  
  ns <- NS(id)
  if(is.null(mappings)){
    mappings<-unique(meta[,c('domain','text_key')]) %>% mutate(current="")
  }
  # check inputs
  stopifnot(
    is.data.frame(meta), 
    is.list(domainData), 
    all(domainData %>% lapply(is.data.frame) %>% unlist),
    is.data.frame(mappings),
    is.character(mappings$text_key),
    is.character(meta$text_key)
  )
  
  #intialize a domain mapping for each domain in the metadata with a data set in domainData
  domain_ui <- list()
  metaDomains <- unique(meta$domain)
  dataDomains <- names(domainData)
  domains <- metaDomains[metaDomains %in% dataDomains]
  print(standards)
  
  for(i in 1:length(domains)){
    
    current_meta <- meta %>% filter(domain == !!domains[i])
    domain<-domains[i]
    current_mapping <- mappings %>% filter(domain %in% !!domains[i]) %>% select(-"domain")
    current_standard <- standards[[domain]]
    domain_ui[[i]] <-div(class="mapping-domain",
      div(class="domain-header",
        span(class="domain-title", str_to_upper(domain)),
        div(class="domain-wrap",
            span(class="domain-label", "Dimension"),
            span(class="domain-value", paste(dim(domainData[[domain]]),collapse="x")),
        ),
        div(class="domain-wrap",
            span(class="domain-label", "Standard"),
            span(class="domain-value", current_standard[["label"]])
        )
      ),
      div(class="domain-body row",
        div(class="domain-controls col-md-3", mappingDomainUI(ns(domain), current_meta, domainData[[domain]], current_mapping)),
        div(class="domain-preview col-md-9", DT::DTOutput(ns(paste0(domain,"-preview"))))
      )
    )
  }
  domain_ui<- list(
    h1("Data Mapping"),
    span("This page dynamically establishes which columns and fields from the loaded data map to different chart properties. When possible, data standards are automatically detected and values are pre-filled."),
    checkboxInput(ns("toggleData"), "Show Data Previews?", FALSE),
    br(),
    domain_ui
  )

  return(domain_ui)
}


#' @title  mapping module server
#' @description  server function that facilitates the mapping of a single data domain
#'
#' @param input Shiny input object
#' @param output  Shiny output object
#' @param session Shiny session object
#' @param meta metadata for all domains
#' @param domainData clinical data for all domains
#' 
#' @return list of mappings for all domains
#'
#' @importFrom shinyjs addClass show removeClass hide
#' 
#' @export

mappingTab <- function(input, output, session, meta, domainData){
  metaDomains <- unique(meta$domain)
  dataDomains <- names(domainData)
  domain_ids <- metaDomains[metaDomains %in% dataDomains]

  if(length(domain_ids) < length(metaDomains)){
    domains_noData <- metaDomains[!(metaDomains %in% dataDomains)]
    message("No data sets provided for the following domains listed in metadata: ",paste(domains_noData, collapse=", "))
  }

  observeEvent(input$toggleData,{
    if(input$toggleData){
      shinyjs::addClass(class="col-md-3", selector = ".domain-controls")
      shinyjs::show(selector = ".domain-body .domain-preview")
    }else{
      shinyjs::removeClass(class="col-md-3", selector = ".domain-controls")
      shinyjs::hide(selector = ".domain-body .domain-preview")
    }
  })

  #show data previews
  lapply(domain_ids, function(domain){
    output[[paste0(domain,"-preview")]] <- renderDT({
      DT::datatable(
        domainData[[domain]], 
        rownames = FALSE,
        options = list(
          scrollX=TRUE
        ),
        class="compact"
      )
    })
  })

  names(domain_ids)<-domain_ids # so that lapply() creates a named list below
  domain_modules <- domain_ids %>% lapply(function(domain){
    this_meta<- meta%>%filter(domain==!!domain)
    this_data <- domainData[[domain]]
    callModule(mappingDomain, domain, this_meta ,this_data)
  })

  reactive({
    data<-data.frame()
    for(domain in domain_ids){
      current<-domain_modules[[domain]]() 
      current$domain <- domain
      current <- current %>% select(.data$domain, .data$text_key, .data$current)
      data<-rbind(data, current)
    }
    return(data)
  })
}
